"use server"
import { createAdminClient } from "@/lib/supabase/admin"
import { revalidatePath } from "next/cache"
import bcrypt from "bcryptjs"
import { cookies } from "next/headers"
import type {
  LandPlot,
  Subscriber,
  Lead,
  User,
  News,
  CommercialProposal,
  CommercialProposalWithDetails,
  OrganizationSettings,
  Settlement,
  LEAD_STATUS_OPTIONS,
  KALININGRAD_DISTRICTS,
  LAND_STATUS_OPTIONS,
  USER_ROLE_OPTIONS,
  LandingBenefitsSection,
  LandingBenefitItem,
  LandPlotData,
  SyncResult,
  FaqItem,
  LegalContent,
} from "@/lib/types"

import { clearAdminSessionCookie } from "@/lib/admin-auth"
import { notifyNewApplication, notifyAdminError, sendMessageToAdmin, sendMessageWithButtons } from "@/lib/telegram"
import { NspdClient } from "@/lib/nspd-service/nspd-client"
import { KALININGRAD_SETTLEMENTS } from "@/lib/kaliningrad-settlements"

// ============ LAND PLOTS ============

export async function createPlot(data: Partial<LandPlot>): Promise<LandPlot | null> {
  const supabase = createAdminClient()

  const { data: plot, error } = await supabase
    .from("land_plots")
    .insert({
      title: data.title,
      description: data.description,
      price: data.price,
      area_sotok: data.area_sotok,
      district: data.district,
      location: data.location,
      land_status: data.land_status,
      has_gas: data.has_gas,
      has_electricity: data.has_electricity,
      has_water: data.has_water,
      has_installment: data.has_installment,
      image_url: data.image_url,
      is_featured: data.is_featured,
      is_active: data.is_active,
      cadastral_number: data.cadastral_number,
      ownership_type: data.ownership_type,
    })
    .select()
    .single()

  if (error) {
    console.error("Error creating plot:", error)
    throw new Error(error.message)
  }

  if (!plot.image_url) {
    const { data: placeholders, error: placeholdersError } = await supabase
      .from("plot_placeholders")
      .select("id, storage_path, public_url")

    if (!placeholdersError && placeholders && placeholders.length > 0) {
      const picked = placeholders[Math.floor(Math.random() * placeholders.length)]

      const { error: updatePlotError } = await supabase
        .from("land_plots")
        .update({ image_url: picked.public_url, updated_at: new Date().toISOString() })
        .eq("id", plot.id)

      if (!updatePlotError) {
        await supabase.from("land_plot_images").insert({
          plot_id: plot.id,
          storage_path: picked.storage_path,
          public_url: picked.public_url,
          is_cover: true,
        })

        plot.image_url = picked.public_url
      }
    }
  }

  revalidatePath("/")
  revalidatePath("/admin")

  if (plot.id && plot.cadastral_number) {
    // Fire and forget coordinate sync
    syncPlotCoordinates(plot.id, plot.cadastral_number).catch(console.error)
  }

  return plot as LandPlot
}

export async function updatePlot(id: string, data: Partial<LandPlot>): Promise<LandPlot | null> {
  const supabase = createAdminClient()

  // Perform update without select to avoid PGRST116 error
  const { error: updateError } = await supabase
    .from("land_plots")
    .update({
      title: data.title,
      description: data.description,
      price: data.price,
      area_sotok: data.area_sotok,
      district: data.district,
      location: data.location,
      land_status: data.land_status,
      has_gas: data.has_gas,
      has_electricity: data.has_electricity,
      has_water: data.has_water,
      has_installment: data.has_installment,
      image_url: data.image_url,
      is_featured: data.is_featured,
      is_active: data.is_active,
      cadastral_number: data.cadastral_number,
      ownership_type: data.ownership_type,
      updated_at: new Date().toISOString(),
    })
    .eq("id", id)

  if (updateError) {
    console.error("Error updating plot:", updateError)
    throw new Error(updateError.message)
  }

  // Fetch the updated plot separately
  const { data: plot, error: selectError } = await supabase.from("land_plots").select("*").eq("id", id).single()

  if (selectError || !plot) {
    console.error("Error fetching updated plot:", selectError)
    throw new Error(selectError?.message || "Plot not found after update")
  }

  revalidatePath("/")
  revalidatePath("/admin")

  if (plot.cadastral_number) {
    // Re-sync coordinates if cadastral number is provided/changed
    syncPlotCoordinates(plot.id, plot.cadastral_number).catch(console.error)
  }

  return plot as LandPlot
}

export async function deletePlot(id: string): Promise<void> {
  const supabase = createAdminClient()

  const { error } = await supabase.from("land_plots").delete().eq("id", id)

  if (error) {
    console.error("Error deleting plot:", error)
    throw new Error(error.message)
  }

  revalidatePath("/")
  revalidatePath("/admin")
}

export async function getLandPlotById(id: string): Promise<LandPlot | null> {
  const supabase = createAdminClient()

  try {
    const { data, error } = await supabase.from("land_plots").select("*").eq("id", id).single()

    if (error) {
      console.error("[v0] Error fetching land plot:", error)
      return null
    }

    return data as LandPlot
  } catch (error) {
    console.error("[v0] Error in getLandPlotById:", error)
    return null
  }
}

// ============ SUBSCRIBERS ============

export async function createSubscriber(email: string): Promise<{ success: boolean; error?: string }> {
  const supabase = createAdminClient()

  const { error } = await supabase.from("subscribers").insert({ email })

  if (error) {
    if (error.code === "23505") {
      return { success: false, error: "–≠—Ç–æ—Ç email —É–∂–µ –ø–æ–¥–ø–∏—Å–∞–Ω" }
    }
    console.error("Error creating subscriber:", error)
    return { success: false, error: "–û—à–∏–±–∫–∞ –ø–æ–¥–ø–∏—Å–∫–∏" }
  }

  revalidatePath("/admin")
  return { success: true }
}

export async function createViewingLead(data: {
  plot: {
    id: string
    location: string | null
    cadastral_number: string | null
    price: number | null
    area_sotok: number | null
  }
  phone: string
  name?: string
  messenger_whatsapp?: boolean
  messenger_telegram?: boolean
}): Promise<{ success: boolean; error?: string }> {
  const supabase = createAdminClient()

  const { error } = await supabase.from("leads").insert({
    name: data.name?.trim() || "–ë–µ–∑ –∏–º–µ–Ω–∏",
    phone: data.phone,
    wishes: null,
    lead_type: "viewing",
    plot_id: data.plot.id,
    plot_location: data.plot.location,
    plot_cadastral_number: data.plot.cadastral_number,
    plot_price: data.plot.price,
    plot_area_sotok: data.plot.area_sotok,
    messenger_whatsapp: !!data.messenger_whatsapp,
    messenger_telegram: !!data.messenger_telegram,
    status: "new",
  })

  if (error) {
    console.error("Error creating viewing lead:", error)
    return { success: false, error: "–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –∑–∞—è–≤–∫–∏" }
  }

  // Telegram —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ —Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ –º–µ—Å—Å–µ–Ω–¥–∂–µ—Ä–∞—Ö
  const cleanPhone = data.phone.replace(/\D/g, '')
  const messengers: string[] = []
  if (data.messenger_telegram) messengers.push('Telegram')
  if (data.messenger_whatsapp) messengers.push('WhatsApp')

  const priceFormatted = data.plot.price ? `${(data.plot.price / 1000000).toFixed(1)} –º–ª–Ω ‚ÇΩ` : '–Ω–µ —É–∫–∞–∑–∞–Ω–∞'
  const areaFormatted = data.plot.area_sotok ? `${data.plot.area_sotok} —Å–æ—Ç.` : ''

  let message = `üîî <b>–ù–æ–≤–∞—è –∑–∞—è–≤–∫–∞ –Ω–∞ –ø—Ä–æ—Å–º–æ—Ç—Ä!</b>

üë§ <b>–ò–º—è:</b> ${data.name || '–ë–µ–∑ –∏–º–µ–Ω–∏'}
üìû <b>–¢–µ–ª–µ—Ñ–æ–Ω:</b> ${data.phone}`

  if (messengers.length > 0) {
    message += `\nüí¨ <b>–ú–µ—Å—Å–µ–Ω–¥–∂–µ—Ä—ã:</b> ${messengers.join(', ')}`
  }

  // –§–æ—Ä–º–∏—Ä—É–µ–º –∫–ª–∏–∫–∞–±–µ–ª—å–Ω—É—é —Å—Å—ã–ª–∫—É –Ω–∞ –∫–∞–¥–∞—Å—Ç—Ä–æ–≤—É—é –∫–∞—Ä—Ç—É
  const cadastralLink = data.plot.cadastral_number
    ? `<a href="https://nspd.gov.ru/map?thematic=PKK&query=${encodeURIComponent(data.plot.cadastral_number)}">${data.plot.cadastral_number}</a>`
    : '‚Äî'

  message += `

üèû <b>–£—á–∞—Å—Ç–æ–∫:</b> ${data.plot.location || '–ù–µ —É–∫–∞–∑–∞–Ω'}
üìç <b>–ö–∞–¥–∞—Å—Ç—Ä:</b> ${cadastralLink}
üí∞ <b>–¶–µ–Ω–∞:</b> ${priceFormatted} ${areaFormatted ? `(${areaFormatted})` : ''}

üì≤ <b>–ë—ã—Å—Ç—Ä–∞—è —Å–≤—è–∑—å:</b>
‚Ä¢ <a href="https://wa.me/${cleanPhone}">WhatsApp</a>
‚Ä¢ <a href="tel:${data.phone}">–ü–æ–∑–≤–æ–Ω–∏—Ç—å</a>
‚Ä¢ <a href="https://max.ru/im?phone=${cleanPhone}">MAX</a>`

  // Inline-–∫–Ω–æ–ø–∫–∏ –¥–ª—è –±—ã—Å—Ç—Ä—ã—Ö –¥–µ–π—Å—Ç–≤–∏–π
  const buttons = [
    [
      { text: 'üìã –ö–ü –ø–æ —É—á–∞—Å—Ç–∫—É', callback_data: `kp:${data.plot.id}` },
      { text: 'üèò –í—Å–µ –≤ –ø–æ—Å—ë–ª–∫–µ', callback_data: `location:${data.plot.location || ''}` },
    ],
    [
      { text: '‚úÖ –û–±—Ä–∞–±–æ—Ç–∞–Ω–æ', callback_data: `done:${data.plot.id}` },
    ]
  ]

  await sendMessageWithButtons(message, buttons)

  revalidatePath("/admin")
  return { success: true }
}

// ============ LANDING BENEFITS (HOMEPAGE BLOCK) ============

const LANDING_BENEFITS_SECTION_ID = "00000000-0000-0000-0000-000000000002"

export async function getLandingBenefits(): Promise<{
  section: LandingBenefitsSection | null
  items: LandingBenefitItem[]
}> {
  const supabase = createAdminClient()

  const [{ data: section, error: sectionError }, { data: items, error: itemsError }] = await Promise.all([
    supabase.from("landing_benefits_section").select("*").eq("id", LANDING_BENEFITS_SECTION_ID).single(),
    supabase
      .from("landing_benefit_items")
      .select("*")
      .eq("section_id", LANDING_BENEFITS_SECTION_ID)
      .order("sort_order", { ascending: true }),
  ])

  if (sectionError) {
    console.error("Error fetching landing benefits section:", sectionError)
  }
  if (itemsError) {
    console.error("Error fetching landing benefit items:", itemsError)
  }

  return {
    section: (section as LandingBenefitsSection) || null,
    items: (items as LandingBenefitItem[]) || [],
  }
}

export async function updateLandingBenefits(input: {
  section: Partial<LandingBenefitsSection>
  items: Array<Partial<LandingBenefitItem> & { id?: string }>
}): Promise<{ success: boolean; error?: string }> {
  const supabase = createAdminClient()

  const { section, items } = input

  const { error: sectionError } = await supabase
    .from("landing_benefits_section")
    .update({
      ...section,
      updated_at: new Date().toISOString(),
    })
    .eq("id", LANDING_BENEFITS_SECTION_ID)

  if (sectionError) {
    console.error("Error updating landing benefits section:", sectionError)
    return { success: false, error: "–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å–µ–∫—Ü–∏–∏" }
  }

  const payload = items.map((it, idx) => {
    const id = it.id || crypto.randomUUID()
    return {
      id,
      section_id: LANDING_BENEFITS_SECTION_ID,
      title: it.title ?? "",
      description: it.description ?? "",
      icon_type: it.icon_type ?? "lucide",
      icon_name: it.icon_name ?? null,
      icon_url: it.icon_url ?? null,
      color_class: it.color_class ?? "bg-primary/10 text-primary",
      sort_order: it.sort_order ?? idx + 1,
      is_active: it.is_active ?? true,
      updated_at: new Date().toISOString(),
    }
  })

  const { error: upsertError } = await supabase
    .from("landing_benefit_items")
    .upsert(payload, { onConflict: "id" })

  if (upsertError) {
    console.error("Error upserting landing benefit items:", upsertError)
    return { success: false, error: "–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –∫–∞—Ä—Ç–æ—á–µ–∫" }
  }

  revalidatePath("/admin")
  revalidatePath("/")

  return { success: true }
}

export async function getSubscribers(): Promise<Subscriber[]> {
  const supabase = createAdminClient()

  const { data, error } = await supabase.from("subscribers").select("*").order("created_at", { ascending: false })

  if (error) {
    console.error("Error fetching subscribers:", error)
    return []
  }

  return data as Subscriber[]
}

export async function deleteSubscriber(id: string): Promise<void> {
  const supabase = createAdminClient()

  const { error } = await supabase.from("subscribers").delete().eq("id", id)

  if (error) {
    console.error("Error deleting subscriber:", error)
    throw new Error(error.message)
  }

  revalidatePath("/admin")
}

export async function updateSubscriber(id: string, is_active: boolean): Promise<{ success: boolean; error?: string }> {
  const supabase = createAdminClient()

  const { error } = await supabase.from("subscribers").update({ is_active }).eq("id", id)

  if (error) {
    console.error("Error updating subscriber:", error)
    return { success: false, error: "–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ø–æ–¥–ø–∏—Å—á–∏–∫–∞" }
  }

  revalidatePath("/admin")
  return { success: true }
}

// ============ LEADS ============

export async function createLead(data: {
  name: string;
  phone: string;
  wishes?: string;
  lead_type?: "general" | "faq";
}): Promise<{
  success: boolean
  error?: string
}> {
  const supabase = createAdminClient()

  const { error } = await supabase.from("leads").insert({
    name: data.name,
    phone: data.phone,
    wishes: data.wishes || null,
    lead_type: data.lead_type || "general",
    status: "new",
  })

  if (error) {
    console.error("Error creating lead:", error)
    return { success: false, error: "–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –∑–∞—è–≤–∫–∏" }
  }

  // Telegram —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
  const typeText = data.lead_type === "faq" ? "–í–æ–ø—Ä–æ—Å –∏–∑ FAQ" : "–ù–æ–≤–∞—è –∑–∞—è–≤–∫–∞"
  await sendMessageToAdmin(`üîî <b>${typeText}!</b>

üë§ <b>–ò–º—è:</b> ${data.name}
üìû <b>–¢–µ–ª–µ—Ñ–æ–Ω:</b> ${data.phone}${data.wishes ? `\nüí¨ ${data.lead_type === 'faq' ? '–í–æ–ø—Ä–æ—Å' : '–ü–æ–∂–µ–ª–∞–Ω–∏—è'}: ${data.wishes}` : ''}`)

  revalidatePath("/admin")
  return { success: true }
}

export async function getLeads(): Promise<Lead[]> {
  const supabase = createAdminClient()

  const { data, error } = await supabase.from("leads").select("*").order("created_at", { ascending: false })

  if (error) {
    console.error("Error fetching leads:", error)
    return []
  }

  return data as Lead[]
}

export async function updateLead(id: string, data: Partial<Lead>): Promise<Lead | null> {
  const supabase = createAdminClient()

  const { data: lead, error } = await supabase
    .from("leads")
    .update({
      wishes: data.wishes,
      status: data.status,
      manager_comment: data.manager_comment,
      updated_at: new Date().toISOString(),
    })
    .eq("id", id)
    .select()
    .single()

  if (error) {
    console.error("Error updating lead:", error)
    throw new Error(error.message)
  }

  revalidatePath("/admin")
  return lead as Lead
}

export async function deleteLead(id: string): Promise<void> {
  const supabase = createAdminClient()

  const { error } = await supabase.from("leads").delete().eq("id", id)

  if (error) {
    console.error("Error deleting lead:", error)
    throw new Error(error.message)
  }

  revalidatePath("/admin")
}

// ============ USERS ============

export async function getUsers(): Promise<User[]> {
  const supabase = createAdminClient()

  const { data, error } = await supabase
    .from("users")
    .select("id, email, name, role, is_active, created_at, updated_at")
    .order("created_at", { ascending: false })

  if (error) {
    console.error("Error fetching users:", error)
    return []
  }

  return data as User[]
}

export async function createUser(data: { email: string; password: string; name: string; role: string }): Promise<{
  success: boolean
  error?: string
}> {
  if (!data.email || !data.email.trim()) {
    return { success: false, error: "Email –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω" }
  }
  if (!data.name || !data.name.trim()) {
    return { success: false, error: "–ò–º—è –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ" }
  }
  if (!data.password || !data.password.trim()) {
    return { success: false, error: "–ü–∞—Ä–æ–ª—å –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω" }
  }

  const supabase = createAdminClient()

  // Simple hash for demo - in production use bcrypt
  const password_hash = btoa(data.password + "_salt_baltikzemlya")

  const { error } = await supabase.from("users").insert({
    email: data.email.trim(),
    password_hash,
    name: data.name.trim(),
    role: data.role,
    is_active: true,
  })

  if (error) {
    if (error.code === "23505") {
      return { success: false, error: "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º email —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç" }
    }
    console.error("Error creating user:", error)
    return { success: false, error: "–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è" }
  }

  revalidatePath("/admin")
  return { success: true }
}

export async function updateUser(id: string, data: Partial<User> & { password?: string }): Promise<User | null> {
  const supabase = createAdminClient()

  const updateData: Record<string, unknown> = {
    name: data.name,
    email: data.email,
    role: data.role,
    is_active: data.is_active,
    updated_at: new Date().toISOString(),
  }

  if (data.password) {
    updateData.password_hash = btoa(data.password + "_salt_baltikzemlya")
  }

  const { data: user, error } = await supabase
    .from("users")
    .update(updateData)
    .eq("id", id)
    .select("id, email, name, role, is_active, created_at, updated_at")
    .single()

  if (error) {
    console.error("Error updating user:", error)
    throw new Error(error.message)
  }

  revalidatePath("/admin")
  return user as User
}

export async function deleteUser(id: string): Promise<void> {
  const supabase = createAdminClient()

  const { error } = await supabase.from("users").delete().eq("id", id)

  if (error) {
    console.error("Error deleting user:", error)
    throw new Error(error.message)
  }

  revalidatePath("/admin")
}

// ============ STATS ============

export async function getAdminStats(): Promise<{
  totalPlots: number
  activePlots: number
  featuredPlots: number
  totalArea: number
  newLeadsToday: number
  newLeadsWeek: number
  totalLeads: number
  totalSubscribers: number
  avgPricePerSotka: number
  totalValue: number
}> {
  const supabase = createAdminClient()

  const [plotsRes, leadsRes, subscribersRes] = await Promise.all([
    supabase.from("land_plots").select("price, area_sotok, is_active, is_featured"),
    supabase.from("leads").select("created_at"),
    supabase.from("subscribers").select("id"),
  ])

  const plots = plotsRes.data || []
  const leads = leadsRes.data || []
  const subscribers = subscribersRes.data || []

  const today = new Date()
  today.setHours(0, 0, 0, 0)
  const weekAgo = new Date(today)
  weekAgo.setDate(weekAgo.getDate() - 7)

  const activePlots = plots.filter((p) => p.is_active)
  const totalValue = activePlots.reduce((sum, p) => sum + p.price, 0)
  const totalArea = activePlots.reduce((sum, p) => sum + p.area_sotok, 0)

  return {
    totalPlots: plots.length,
    activePlots: activePlots.length,
    featuredPlots: plots.filter((p) => p.is_featured).length,
    totalArea: Math.round(totalArea),
    newLeadsToday: leads.filter((l) => new Date(l.created_at) >= today).length,
    newLeadsWeek: leads.filter((l) => new Date(l.created_at) >= weekAgo).length,
    totalLeads: leads.length,
    totalSubscribers: subscribers.length,
    avgPricePerSotka: totalArea > 0 ? Math.round(totalValue / totalArea) : 0,
    totalValue,
  }
}

// ============ NEWS ============

export async function getNews(publishedOnly = false): Promise<News[]> {
  const supabase = createAdminClient()

  let query = supabase.from("news").select("*").order("published_at", { ascending: false })

  if (publishedOnly) {
    query = query.eq("is_published", true)
  }

  const { data, error } = await query

  if (error) {
    console.error("Error fetching news:", error)
    return []
  }

  return data as News[]
}

export async function createNews(data: { title: string; content: string; image_url?: string }): Promise<News | null> {
  const supabase = createAdminClient()

  const { data: news, error } = await supabase
    .from("news")
    .insert({
      title: data.title,
      content: data.content,
      image_url: data.image_url || null,
      is_published: false,
    })
    .select()
    .single()

  if (error) {
    console.error("Error creating news:", error)
    throw new Error(error.message)
  }

  revalidatePath("/")
  revalidatePath("/admin")

  return news as News
}

export async function updateNews(
  id: string,
  data: { title?: string; content?: string; image_url?: string; is_published?: boolean },
): Promise<News | null> {
  const supabase = createAdminClient()

  const updateData: Record<string, unknown> = {
    ...data,
    updated_at: new Date().toISOString(),
  }

  // If publishing for the first time, set published_at
  if (data.is_published) {
    updateData.published_at = new Date().toISOString()
  }

  const { data: news, error } = await supabase.from("news").update(updateData).eq("id", id).select().single()

  if (error) {
    console.error("Error updating news:", error)
    throw new Error(error.message)
  }

  revalidatePath("/")
  revalidatePath("/admin")

  return news as News
}

export async function deleteNews(id: string): Promise<void> {
  const supabase = createAdminClient()

  const { error } = await supabase.from("news").delete().eq("id", id)

  if (error) {
    console.error("Error deleting news:", error)
    throw new Error(error.message)
  }

  revalidatePath("/")
  revalidatePath("/admin")
}

// ============ COMMERCIAL PROPOSALS ============

export async function createProposal(data: {
  lead_id: string
  title: string
  description?: string
  plot_ids: string[]
}): Promise<{ success: boolean; proposal?: CommercialProposal; error?: string }> {
  try {
    const supabase = createAdminClient()

    // Create proposal
    const { data: proposal, error: proposalError } = await supabase
      .from("commercial_proposals")
      .insert({
        lead_id: data.lead_id,
        title: data.title,
        description: data.description || null,
        status: "draft",
      })
      .select()
      .single()

    if (proposalError) {
      console.error("Error creating proposal:", proposalError)
      return { success: false, error: "–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –ö–ü" }
    }

    // Add plots to proposal
    if (data.plot_ids.length > 0) {
      const proposalPlots = data.plot_ids.map((plot_id, index) => ({
        proposal_id: proposal.id,
        plot_id,
        sort_order: index,
      }))

      const { data: insertedPlots, error: plotsError } = await supabase
        .from("commercial_proposal_plots")
        .insert(proposalPlots)
        .select()

      if (plotsError) {
        console.error("Error adding plots to proposal:", plotsError)
        // Rollback - delete the proposal
        await supabase.from("commercial_proposals").delete().eq("id", proposal.id)
        return { success: false, error: "–û—à–∏–±–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —É—á–∞—Å—Ç–∫–æ–≤ –≤ –ö–ü" }
      }
    }

    revalidatePath("/admin")
    return { success: true, proposal: proposal as CommercialProposal }
  } catch (error) {
    console.error("Error in createProposal:", error)
    return { success: false, error: String(error) }
  }
}

export async function getProposalsByLead(lead_id: string): Promise<CommercialProposalWithDetails[]> {
  const supabase = createAdminClient()

  const { data, error } = await supabase
    .from("commercial_proposals")
    .select(
      `
      *,
      commercial_proposal_plots (
        *,
        plot:land_plots (*)
      )
    `,
    )
    .eq("lead_id", lead_id)
    .order("created_at", { ascending: false })

  if (error) {
    console.error("Error fetching proposals:", error)
    return []
  }

  return data as CommercialProposalWithDetails[]
}

export async function getProposalById(id: string): Promise<CommercialProposalWithDetails | null> {
  const supabase = createAdminClient()

  const { data, error } = await supabase
    .from("commercial_proposals")
    .select(
      `
      *,
      lead:leads (*),
      commercial_proposal_plots (
        *,
        plot:land_plots (*)
      )
    `,
    )
    .eq("id", id)
    .single()

  if (error) {
    console.error("Error fetching proposal:", error)
    return null
  }

  return data as CommercialProposalWithDetails
}

export async function updateProposal(
  id: string,
  data: Partial<CommercialProposal>,
): Promise<{ success: boolean; error?: string }> {
  const supabase = createAdminClient()

  const { error } = await supabase
    .from("commercial_proposals")
    .update({
      ...data,
      updated_at: new Date().toISOString(),
    })
    .eq("id", id)

  if (error) {
    console.error("Error updating proposal:", error)
    return { success: false, error: "–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ö–ü" }
  }

  revalidatePath("/admin")
  return { success: true }
}

export async function deleteProposal(id: string): Promise<{ success: boolean; error?: string }> {
  const supabase = createAdminClient()

  const { error } = await supabase.from("commercial_proposals").delete().eq("id", id)

  if (error) {
    console.error("Error deleting proposal:", error)
    return { success: false, error: "–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è –ö–ü" }
  }

  revalidatePath("/admin")
  return { success: true }
}

// ============ ADMIN AUTHENTICATION ============

export async function loginAdmin(
  username: string,
  password: string,
): Promise<{ success: boolean; token?: string; error?: string }> {
  const supabase = createAdminClient()

  const { data: adminUser, error } = await supabase.from("admin_users").select("*").eq("username", username).single()

  if (error || !adminUser) {
    return { success: false, error: "–ù–µ–≤–µ—Ä–Ω—ã–π –ª–æ–≥–∏–Ω –∏–ª–∏ –ø–∞—Ä–æ–ª—å" }
  }

  const isValid = await bcrypt.compare(password, adminUser.password_hash)

  if (!isValid) {
    return { success: false, error: "–ù–µ–≤–µ—Ä–Ω—ã–π –ª–æ–≥–∏–Ω –∏–ª–∏ –ø–∞—Ä–æ–ª—å" }
  }

  const sessionToken = btoa(JSON.stringify({ id: adminUser.id, username: adminUser.username, timestamp: Date.now() }))

  return { success: true, token: sessionToken }
}

export async function logoutAdmin(): Promise<void> {
  await clearAdminSessionCookie()
}

export async function checkAdminSession(): Promise<boolean> {
  const cookieStore = await cookies()
  const session = cookieStore.get("admin_session")
  return !!session
}

export async function resetAdminPassword(): Promise<{ success: boolean; hash?: string; error?: string }> {
  try {
    const supabase = createAdminClient()

    const correctHash = await bcrypt.hash("123", 10)

    const { error } = await supabase.from("admin_users").update({ password_hash: correctHash }).eq("username", "admin")

    if (error) {
      console.error("[v0] Error updating password:", error)
      return { success: false, error: error.message }
    }

    return { success: true, hash: correctHash }
  } catch (error) {
    console.error("[v0] Error resetting password:", error)
    return { success: false, error: String(error) }
  }
}

// ============ LAND PLOTS FETCHING ============

export async function getLandPlots(): Promise<LandPlot[]> {
  try {
    const supabase = createAdminClient()

    const { data, error } = await supabase
      .from("land_plots")
      .select("*")
      .eq("is_active", true)
      .order("district", { ascending: true })
      .order("price", { ascending: true })

    if (error) {
      console.error("[v0] Error fetching land plots:", error)
      return []
    }

    return data as LandPlot[]
  } catch (err) {
    console.error("[v0] Exception fetching land plots:", err)
    return []
  }
}

// ============ ORGANIZATION SETTINGS ============

export async function getOrganizationSettings(): Promise<OrganizationSettings | null> {
  const supabase = createAdminClient()

  const { data, error } = await supabase
    .from("organization_settings")
    .select("*")
    .eq("id", "00000000-0000-0000-0000-000000000001")
    .single()

  if (error) {
    console.error("Error fetching organization settings:", error)
    return null
  }

  return data as OrganizationSettings
}

export async function updateOrganizationSettings(
  data: Partial<OrganizationSettings>,
): Promise<{ success: boolean; error?: string }> {
  const supabase = createAdminClient()

  const { error } = await supabase
    .from("organization_settings")
    .update({
      ...data,
      updated_at: new Date().toISOString(),
    })
    .eq("id", "00000000-0000-0000-0000-000000000001")

  if (error) {
    console.error("Error updating organization settings:", error)
    return { success: false, error: "–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –Ω–∞—Å—Ç—Ä–æ–µ–∫" }
  }

  revalidatePath("/admin")
  revalidatePath("/")
  return { success: true }
}

// ============ ALL PROPOSALS FOR MULTIPLE LEADS ============

export async function getAllProposalsForLeads(
  lead_ids: string[],
): Promise<Record<string, CommercialProposalWithDetails[]>> {
  if (lead_ids.length === 0) return {}

  const supabase = createAdminClient()

  const { data, error } = await supabase
    .from("commercial_proposals")
    .select(
      `
      *,
      commercial_proposal_plots (
        *,
        plot:land_plots (*)
      )
    `,
    )
    .in("lead_id", lead_ids)
    .order("created_at", { ascending: false })

  if (error) {
    console.error("Error fetching proposals:", error)
    return {}
  }

  // Group by lead_id
  const proposalsByLead: Record<string, CommercialProposalWithDetails[]> = {}
  for (const proposal of data as CommercialProposalWithDetails[]) {
    if (!proposalsByLead[proposal.lead_id]) {
      proposalsByLead[proposal.lead_id] = []
    }
    proposalsByLead[proposal.lead_id].push(proposal)
  }

  return proposalsByLead
}

// ============ LAND PLOT IMPORT/EXPORT ============

export async function syncLandPlotsFromData(
  landPlotsData: LandPlotData[],
  settlement: string,
  replaceAll = false,
  logData?: { fileName: string; fileType: string },
  autoResolve = false,
  skipLogging = false,
): Promise<SyncResult> {
  console.log(
    `[v0] Starting sync for ${landPlotsData.length} plots. Mode: ${replaceAll ? "REPLACE ALL" : `Settlement: ${settlement}`}`,
  )

  const supabase = createAdminClient()
  const results: SyncResult = {
    success: true,
    message: "",
    added: 0,
    updated: 0,
    deleted: 0,
    errors: [],
    details: [],
  }

  if (replaceAll) {
    console.log(`[v0] REPLACE ALL mode: Deleting all existing plots...`)
    try {
      const { error: deleteError } = await supabase
        .from("land_plots")
        .delete()
        .neq("id", "00000000-0000-0000-0000-000000000000") // Delete all rows

      if (deleteError) {
        console.error(`[v0] Error deleting all plots:`, deleteError)
        results.errors.push(`–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö —É—á–∞—Å—Ç–∫–æ–≤: ${deleteError.message}`)
      } else {
        console.log(`[v0] All existing plots deleted successfully`)
      }
    } catch (error) {
      console.error(`[v0] Exception deleting all plots:`, error)
      results.errors.push(`–ò—Å–∫–ª—é—á–µ–Ω–∏–µ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏: ${error instanceof Error ? error.message : String(error)}`)
    }
  }

  const cadastralNumbers = new Set<string>()
  const duplicates = new Set<string>()

  for (const plotData of landPlotsData) {
    if (!plotData.cadastral_number) {
      continue
    }
    if (cadastralNumbers.has(plotData.cadastral_number)) {
      duplicates.add(plotData.cadastral_number)
      results.errors.push(`–î—É–±–ª–∏–∫–∞—Ç –∫–∞–¥–∞—Å—Ç—Ä–æ–≤–æ–≥–æ –Ω–æ–º–µ—Ä–∞ –≤ —Ñ–∞–π–ª–µ: ${plotData.cadastral_number}`)
    }
    cadastralNumbers.add(plotData.cadastral_number)
  }

  const BATCH_SIZE = 10
  const batches = []
  for (let i = 0; i < landPlotsData.length; i += BATCH_SIZE) {
    batches.push(landPlotsData.slice(i, i + BATCH_SIZE))
  }

  const ensurePlotHasPlaceholderCover = async (plotId: string) => {
    const { data: plotRow, error: plotError } = await supabase
      .from("land_plots")
      .select("id, image_url")
      .eq("id", plotId)
      .maybeSingle()

    if (plotError || !plotRow || plotRow.image_url) return

    const { data: placeholders, error: placeholdersError } = await supabase
      .from("plot_placeholders")
      .select("id, storage_path, public_url")

    if (placeholdersError || !placeholders || placeholders.length === 0) return

    const picked = placeholders[Math.floor(Math.random() * placeholders.length)]

    const { error: updatePlotError } = await supabase
      .from("land_plots")
      .update({ image_url: picked.public_url, updated_at: new Date().toISOString() })
      .eq("id", plotId)

    if (updatePlotError) return

    const { count } = await supabase
      .from("land_plot_images")
      .select("id", { count: "exact", head: true })
      .eq("plot_id", plotId)

    if ((count || 0) === 0) {
      await supabase.from("land_plot_images").insert({
        plot_id: plotId,
        storage_path: picked.storage_path,
        public_url: picked.public_url,
        is_cover: true,
      })
    }
  }

  console.log(`[v0] Processing ${batches.length} batches of ${BATCH_SIZE} plots each`)

  for (let batchIndex = 0; batchIndex < batches.length; batchIndex++) {
    const batch = batches[batchIndex]
    console.log(`[v0] Processing batch ${batchIndex + 1}/${batches.length}`)

    for (let i = 0; i < batch.length; i++) {
      const plotData = batch[i]
      const globalIndex = batchIndex * BATCH_SIZE + i + 1

      console.log(
        `[v0] Processing plot ${globalIndex}/${landPlotsData.length}: ${plotData.cadastral_number} - ${plotData.location}`,
      )

      if (!plotData.cadastral_number) {
        results.errors.push(`–°—Ç—Ä–æ–∫–∞ ${globalIndex}: –û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –∫–∞–¥–∞—Å—Ç—Ä–æ–≤—ã–π –Ω–æ–º–µ—Ä`)
        results.details.push({
          line: globalIndex,
          status: "error",
          message: "–û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –∫–∞–¥–∞—Å—Ç—Ä–æ–≤—ã–π –Ω–æ–º–µ—Ä",
          cadastral: "",
        })
        continue
      }

      if (duplicates.has(plotData.cadastral_number)) {
        console.log(`[v0] Skipping duplicate cadastral number: ${plotData.cadastral_number}`)
        results.details.push({
          line: globalIndex,
          status: "skipped",
          message: `–ü—Ä–æ–ø—É—â–µ–Ω (–¥—É–±–ª–∏–∫–∞—Ç): ${plotData.location} (${plotData.cadastral_number})`,
          cadastral: plotData.cadastral_number,
        })
        continue
      }

      try {
        if (replaceAll) {
          console.log(`[v0] REPLACE ALL mode: Adding new plot: ${plotData.cadastral_number}`)

          let finalDistrict = plotData.district
          let finalLocation = plotData.location
          let autoResolutionError = ""

          if (autoResolve) {
            const resolution = await resolveLocationByCadastral(plotData.cadastral_number)
            if (resolution.error) {
              autoResolutionError = resolution.error
            } else {
              if (resolution.district) finalDistrict = resolution.district
              if (resolution.location) finalLocation = resolution.location
              if (resolution.land_status && !plotData.land_status) {
                plotData.land_status = resolution.land_status
              }
            }
          }

          const { data: insertedPlot, error: insertError } = await supabase
            .from("land_plots")
            .insert({
              title: plotData.title,
              district: finalDistrict,
              location: finalLocation,
              cadastral_number: plotData.cadastral_number,
              area_sotok: plotData.area_sotok,
              price: plotData.price,
              description: plotData.description,
              land_status: plotData.land_status,
              has_gas: plotData.has_gas ?? false,
              has_electricity: plotData.has_electricity ?? false,
              has_water: plotData.has_water ?? false,
              has_installment: plotData.has_installment ?? false,
              is_active: true,
            })
            .select("id")
            .single()

          if (insertError) {
            console.error(`[v0] Error adding plot:`, insertError)
            results.errors.push(`–°—Ç—Ä–æ–∫–∞ ${globalIndex}: –û—à–∏–±–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è - ${insertError.message}`)
            results.details.push({
              line: globalIndex,
              status: "error",
              message: `–û—à–∏–±–∫–∞: ${insertError.message}`,
              cadastral: plotData.cadastral_number,
            })
          } else {
            console.log(`[v0] Successfully added plot ${plotData.cadastral_number}`)
            results.added++
            if (insertedPlot?.id) {
              await ensurePlotHasPlaceholderCover(insertedPlot.id)
            }
            results.details.push({
              line: globalIndex,
              status: "added",
              message: `–î–æ–±–∞–≤–ª–µ–Ω: ${plotData.location} (${plotData.cadastral_number})`,
              cadastral: plotData.cadastral_number,
            })
            // Sync coordinates
            if (insertedPlot?.id) {
              syncPlotCoordinates(insertedPlot.id, plotData.cadastral_number).catch(console.error)
            }
          }
        } else {
          // Original logic for settlement-specific sync
          const { data: existingPlots, error: checkError } = await supabase
            .from("land_plots")
            .select("id, image_url")
            .eq("cadastral_number", plotData.cadastral_number)
            .limit(1)

          if (checkError) {
            console.error(`[v0] Error checking existing plot:`, checkError)
            results.errors.push(`–°—Ç—Ä–æ–∫–∞ ${globalIndex}: –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ - ${checkError.message}`)
            results.details.push({
              line: globalIndex,
              status: "error",
              message: `–û—à–∏–±–∫–∞: ${checkError.message}`,
              cadastral: plotData.cadastral_number,
            })
            continue
          }

          if (existingPlots && existingPlots.length > 0) {
            console.log(`[v0] Updating existing plot: ${existingPlots[0].id}`)

            let finalDistrict = plotData.district
            let finalLocation = plotData.location

            if (autoResolve) {
              const resolution = await resolveLocationByCadastral(plotData.cadastral_number)
              if (!resolution.error) {
                if (resolution.district) finalDistrict = resolution.district
                if (resolution.location) finalLocation = resolution.location
                if (resolution.land_status && (!plotData.land_status || plotData.land_status === "")) {
                  plotData.land_status = resolution.land_status
                }
              }
            }

            const { error: updateError } = await supabase
              .from("land_plots")
              .update({
                title: plotData.title,
                district: finalDistrict,
                location: finalLocation,
                area_sotok: plotData.area_sotok,
                price: plotData.price,
                description: plotData.description,
                land_status: plotData.land_status,
                has_gas: plotData.has_gas ?? false,
                has_electricity: plotData.has_electricity ?? false,
                has_water: plotData.has_water ?? false,
                has_installment: plotData.has_installment ?? false,
                is_active: true,
                updated_at: new Date().toISOString(),
              })
              .eq("id", existingPlots[0].id)

            if (updateError) {
              console.error(`[v0] Error updating plot:`, updateError)
              results.errors.push(`–°—Ç—Ä–æ–∫–∞ ${globalIndex}: –û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è - ${updateError.message}`)
              results.details.push({
                line: globalIndex,
                status: "error",
                message: `–û—à–∏–±–∫–∞: ${updateError.message}`,
                cadastral: plotData.cadastral_number,
              })
            } else {
              console.log(`[v0] Successfully updated plot ${existingPlots[0].id}`)
              results.updated++
              if (!existingPlots[0].image_url) {
                await ensurePlotHasPlaceholderCover(existingPlots[0].id)
              }
              results.details.push({
                line: globalIndex,
                status: "updated",
                message: `–û–±–Ω–æ–≤–ª–µ–Ω: ${plotData.location} (${plotData.cadastral_number})`,
                cadastral: plotData.cadastral_number,
              })
              // Sync coordinates
              syncPlotCoordinates(existingPlots[0].id, plotData.cadastral_number).catch(console.error)
            }
          } else {
            console.log(`[v0] Adding new plot: ${plotData.cadastral_number}`)

            const { data: insertedPlot, error: insertError } = await supabase
              .from("land_plots")
              .insert({
                title: plotData.title,
                district: plotData.district,
                location: plotData.location,
                cadastral_number: plotData.cadastral_number,
                area_sotok: plotData.area_sotok,
                price: plotData.price,
                description: plotData.description,
                land_status: plotData.land_status,
                has_gas: plotData.has_gas ?? false,
                has_electricity: plotData.has_electricity ?? false,
                has_water: plotData.has_water ?? false,
                has_installment: plotData.has_installment ?? false,
                is_active: true,
              })
              .select("id")
              .single()

            if (insertError) {
              console.error(`[v0] Error adding plot:`, insertError)
              results.errors.push(`–°—Ç—Ä–æ–∫–∞ ${globalIndex}: –û—à–∏–±–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è - ${insertError.message}`)
              results.details.push({
                line: globalIndex,
                status: "error",
                message: `–û—à–∏–±–∫–∞: ${insertError.message}`,
                cadastral: plotData.cadastral_number,
              })
            } else {
              console.log(`[v0] Successfully added plot ${plotData.cadastral_number}`)
              results.added++
              if (insertedPlot?.id) {
                await ensurePlotHasPlaceholderCover(insertedPlot.id)
              }
              results.details.push({
                line: globalIndex,
                status: "added",
                message: `–î–æ–±–∞–≤–ª–µ–Ω: ${plotData.location} (${plotData.cadastral_number})`,
                cadastral: plotData.cadastral_number,
              })
              // Sync coordinates
              if (insertedPlot?.id) {
                syncPlotCoordinates(insertedPlot.id, plotData.cadastral_number).catch(console.error)
              }
            }
          }
        }
      } catch (error) {
        console.error(`[v0] Exception processing plot:`, error)
        results.errors.push(
          `–°—Ç—Ä–æ–∫–∞ ${globalIndex}: –ò—Å–∫–ª—é—á–µ–Ω–∏–µ - ${error instanceof Error ? error.message : String(error)}`,
        )
        results.details.push({
          line: globalIndex,
          status: "error",
          message: `–ò—Å–∫–ª—é—á–µ–Ω–∏–µ: ${error instanceof Error ? error.message : String(error)}`,
          cadastral: plotData.cadastral_number,
        })
      }
    }

    if (batchIndex < batches.length - 1) {
      console.log(`[v0] Waiting 500ms before next batch...`)
      await new Promise((resolve) => setTimeout(resolve, 500))
    }
  }

  if (!replaceAll && settlement) {
    try {
      console.log(`[v0] Checking for plots to archive in ${settlement}`)

      const importedCadastralNumbers = Array.from(cadastralNumbers)

      const { data: existingPlots, error: fetchError } = await supabase
        .from("land_plots")
        .select("id, cadastral_number")
        .eq("location", settlement)
        .eq("is_active", true)

      if (fetchError) {
        console.error(`[v0] Error fetching existing plots:`, fetchError)
        results.errors.push(`–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–∏—Å–∫–µ —É—á–∞—Å—Ç–∫–æ–≤ –¥–ª—è –∞—Ä—Ö–∏–≤–∏—Ä–æ–≤–∞–Ω–∏—è: ${fetchError.message}`)
      } else if (existingPlots) {
        const plotsToArchive = existingPlots.filter((plot) => !importedCadastralNumbers.includes(plot.cadastral_number))

        console.log(`[v0] Found ${plotsToArchive.length} plots to archive in ${settlement}`)

        for (const plot of plotsToArchive) {
          const { error: archiveError } = await supabase
            .from("land_plots")
            .update({
              is_active: false,
              updated_at: new Date().toISOString(),
            })
            .eq("id", plot.id)

          if (archiveError) {
            console.error(`[v0] Error archiving plot:`, archiveError)
            results.errors.push(`–û—à–∏–±–∫–∞ –∞—Ä—Ö–∏–≤–∏—Ä–æ–≤–∞–Ω–∏—è ${plot.cadastral_number}: ${archiveError.message}`)
          } else {
            console.log(`[v0] Archived plot: ${plot.cadastral_number}`)
            results.deleted++
            results.details.push({
              line: 0,
              status: "archived",
              message: `–ê—Ä—Ö–∏–≤–∏—Ä–æ–≤–∞–Ω (–Ω–µ –Ω–∞–π–¥–µ–Ω –≤ —Ñ–∞–π–ª–µ): ${plot.cadastral_number}`,
              cadastral: plot.cadastral_number,
            })
          }
        }
      }
    } catch (error) {
      console.error(`[v0] Exception archiving plots:`, error)
      results.errors.push(`–ò—Å–∫–ª—é—á–µ–Ω–∏–µ –ø—Ä–∏ –∞—Ä—Ö–∏–≤–∏—Ä–æ–≤–∞–Ω–∏–∏: ${error instanceof Error ? error.message : String(error)}`)
    }
  }

  if (!skipLogging) {
    try {
      console.log(`[v0] Saving import log to database...`)

      const { error: logError } = await supabase.from("import_logs").insert({
        settlement: replaceAll ? "–ü–æ–ª–Ω–∞—è –±–∞–∑–∞" : settlement,
        file_name: logData?.fileName || `${settlement} import`,
        file_type: logData?.fileType || "PDF",
        added_count: results.added,
        updated_count: results.updated,
        archived_count: results.deleted,
        details: results.details.map((detail) => ({
          cadastral_number: detail.cadastral,
          operation: detail.status,
          settlement: settlement || "Unknown",
          message: detail.message,
        })),
      })

      if (logError) {
        console.error(`[v0] Error saving import log:`, logError)
      } else {
        console.log(`[v0] Import log saved successfully`)
      }
    } catch (error) {
      console.error(`[v0] Exception saving import log:`, error)
    }
  }

  return results
}

export async function createImportLog(data: {
  settlement: string
  file_name: string
  file_type: string
  added_count: number
  updated_count: number
  archived_count: number
  details: any[]
}): Promise<{ success: boolean; error?: string }> {
  const supabase = createAdminClient()

  const { error } = await supabase.from("import_logs").insert({
    settlement: data.settlement,
    file_name: data.file_name,
    file_type: data.file_type,
    added_count: data.added_count,
    updated_count: data.updated_count,
    archived_count: data.archived_count,
    details: data.details,
  })

  if (error) {
    console.error(`[createImportLog] Error:`, error)
    return { success: false, error: error.message }
  }

  return { success: true }
}

export async function exportLandPlotsToJSON(): Promise<{
  success: boolean
  data?: Array<Record<string, unknown>>
  error?: string
}> {
  const supabase = createAdminClient()

  const { data: plots, error } = await supabase
    .from("land_plots")
    .select("*")
    .order("district", { ascending: true })
    .order("location", { ascending: true })

  if (error) {
    return { success: false, error: error.message }
  }

  return {
    success: true,
    data: plots?.map((p) => ({
      "–ù–∞—Å–µ–ª–µ–Ω–Ω—ã–π –ø—É–Ω–∫—Ç": p.location,
      "–¶–µ–Ω–∞ (‚ÇΩ)": p.price,
      "–ü–ª–æ—â–∞–¥—å (—Å–æ—Ç.)": p.area_sotok,
      –†–∞–π–æ–Ω: p.district,
      "–°—Ç–∞—Ç—É—Å –∑–µ–º–ª–∏": p.land_status,
      "–ö–∞–¥–∞—Å—Ç—Ä–æ–≤—ã–π –Ω–æ–º–µ—Ä": p.cadastral_number || "",
      "–§–æ—Ä–º–∞ –≤–ª–∞–¥–µ–Ω–∏—è": p.ownership_type || "ownership",
      –û–ø–∏—Å–∞–Ω–∏–µ: p.description || "",
      –ì–∞–∑: p.has_gas ? "–î–∞" : "–ù–µ—Ç",
      –≠–ª–µ–∫—Ç—Ä–∏—á–µ—Å—Ç–≤–æ: p.has_electricity ? "–î–∞" : "–ù–µ—Ç",
      –í–æ–¥–∞: p.has_water ? "–î–∞" : "–ù–µ—Ç",
      –†–∞—Å—Å—Ä–æ—á–∫–∞: p.has_installment ? "–î–∞" : "–ù–µ—Ç",
      –ê–∫—Ç–∏–≤–µ–Ω: p.is_active ? "–î–∞" : "–ù–µ—Ç",
      –ò–∑–±—Ä–∞–Ω–Ω—ã–π: p.is_featured ? "–î–∞" : "–ù–µ—Ç",
    })),
  }
}

export async function clearAllLandPlots(): Promise<{ success: boolean; message: string; deleted: number }> {
  const supabase = createAdminClient()

  try {
    const { count } = await supabase.from("land_plots").select("id", { count: "exact", head: true })

    const { error: deleteError } = await supabase.from("land_plots").delete().neq("id", "00000000-0000-0000-0000-000000000000") // Delete all

    if (deleteError) {
      return { success: false, message: `–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è: ${deleteError.message}`, deleted: 0 }
    }

    const deleted = count || 0

    await supabase.from("import_logs").insert({
      settlement: "–í—Å–µ –ø–æ—Å–µ–ª–∫–∏",
      file_name: "–ü–æ–ª–Ω–∞—è –æ—á–∏—Å—Ç–∫–∞ –±–∞–∑—ã",
      file_type: "CLEAR_ALL",
      added_count: 0,
      updated_count: 0,
      archived_count: deleted,
      details: [],
    })

    return { success: true, message: `–£–¥–∞–ª–µ–Ω—ã –≤—Å–µ —É—á–∞—Å—Ç–∫–∏ (${deleted} —à—Ç.)`, deleted }
  } catch (error) {
    return {
      success: false,
      message: `–ò—Å–∫–ª—é—á–µ–Ω–∏–µ: ${error instanceof Error ? error.message : String(error)}`,
      deleted: 0,
    }
  }
}

export async function clearLandPlotsBySettlement(
  district: string,
  settlement: string,
): Promise<{ success: boolean; message: string; deleted: number }> {
  const supabase = createAdminClient()

  if (!settlement || settlement.trim().length === 0) {
    return { success: false, message: "–ù–µ —É–∫–∞–∑–∞–Ω –Ω–∞—Å–µ–ª–µ–Ω–Ω—ã–π –ø—É–Ω–∫—Ç", deleted: 0 }
  }

  try {
    const query = supabase.from("land_plots").select("id", { count: "exact", head: true }).eq("location", settlement)
    const scoped = district && district !== "all" ? query.eq("district", district) : query
    const { count } = await scoped

    const deleteQuery = supabase.from("land_plots").delete().eq("location", settlement)
    const deleteScoped = district && district !== "all" ? deleteQuery.eq("district", district) : deleteQuery
    const { error: deleteError } = await deleteScoped

    if (deleteError) {
      return { success: false, message: `–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è: ${deleteError.message}`, deleted: 0 }
    }

    const deleted = count || 0

    await supabase.from("import_logs").insert({
      settlement,
      file_name: "–û—á–∏—Å—Ç–∫–∞ –ø–æ—Å–µ–ª–∫–∞",
      file_type: "CLEAR",
      added_count: 0,
      updated_count: 0,
      archived_count: deleted,
      details: [],
    })

    return { success: true, message: `–£–¥–∞–ª–µ–Ω–æ —É—á–∞—Å—Ç–∫–æ–≤: ${deleted}`, deleted }
  } catch (error) {
    return {
      success: false,
      message: `–ò—Å–∫–ª—é—á–µ–Ω–∏–µ: ${error instanceof Error ? error.message : String(error)}`,
      deleted: 0,
    }
  }
}

export async function getSettlementPlotCounts(): Promise<
  Array<{ district: string | null; settlement: string | null; count: number }>
> {
  const supabase = createAdminClient()

  const { data, error } = await supabase.from("land_plots").select("district, location")

  if (error || !data) {
    console.error("[getSettlementPlotCounts] Error:", error)
    return []
  }

  const map = new Map<string, { district: string | null; settlement: string | null; count: number }>()

  for (const row of data as Array<{ district: string | null; location: string | null }>) {
    const settlement = row.location
    if (!settlement) continue
    const district = row.district
    const key = `${district || ""}||${settlement}`

    const prev = map.get(key)
    if (prev) {
      prev.count += 1
    } else {
      map.set(key, { district, settlement, count: 1 })
    }
  }

  return Array.from(map.values()).sort((a, b) => {
    const ad = (a.district || "").localeCompare(b.district || "", "ru")
    if (ad !== 0) return ad
    return (a.settlement || "").localeCompare(b.settlement || "", "ru")
  })
}

// ============ ADDRESS DATA (Districts, Settlements, Streets) ============
// Using KLADR tables: kladr_places and kladr_streets

export async function getDistricts() {
  const supabase = createAdminClient()

  console.log("[getDistricts] Fetching districts from kladr_places...")

  // Get unique districts from kladr_places where socr indicates district/region
  // In KLADR: —Ä–∞–π–æ–Ω—ã –æ–±—ã—á–Ω–æ –∏–º–µ—é—Ç socr = '—Ä-–Ω' –∏–ª–∏ –ø–æ–¥–æ–±–Ω–æ–µ
  const { data, error } = await supabase
    .from("kladr_places")
    .select("code, name, socr")
    .or("socr.eq.—Ä-–Ω,socr.eq.–≥.–æ.,socr.eq.–≥–æ—Ä–æ–¥—Å–∫–æ–π –æ–∫—Ä—É–≥,socr.eq.—Ä–∞–π–æ–Ω")
    .order("name", { ascending: true })

  if (error) {
    console.error("[getDistricts] Error fetching districts:", error)
    return []
  }

  console.log("[getDistricts] Fetched districts:", data)

  // Transform to match District interface
  return (data || []).map(d => ({
    id: d.code,
    name: `${d.name}${d.socr ? ' ' + d.socr : ''}`,
    name_short: d.name,
    sort_order: 0,
    is_active: true,
    created_at: new Date().toISOString(),
    updated_at: new Date().toISOString()
  }))
}

export async function getSettlements(districtCode?: string) {
  const supabase = createAdminClient()

  console.log("[getSettlements] Fetching settlements from kladr_places...")

  // Get settlements (–≥–æ—Ä–æ–¥–∞, –ø–æ—Å–µ–ª–∫–∏) from kladr_places
  // Filter by district if provided
  let query = supabase
    .from("kladr_places")
    .select("code, name, socr")
    .or("socr.eq.–≥,socr.eq.–ø,socr.eq.–ø–æ—Å,socr.eq.—Å,socr.eq.–¥")

  // If district code provided, filter by it (first 5 or 8 chars of code match)
  if (districtCode) {
    query = query.like("code", `${districtCode.substring(0, 5)}%`)
  }

  const { data, error } = await query.order("name", { ascending: true })

  if (error) {
    console.error("[getSettlements] Error fetching settlements:", error)
    return []
  }

  console.log("[getSettlements] Fetched settlements:", data)

  // Transform to match Settlement interface
  return (data || []).map(s => ({
    id: s.code,
    district_id: districtCode || '',
    name: `${s.socr ? s.socr + '. ' : ''}${s.name}`,
    settlement_type: s.socr,
    sort_order: 0,
    is_active: true,
    created_at: new Date().toISOString(),
    updated_at: new Date().toISOString()
  }))
}

export async function getSettlementsByDistrictName(districtName: string) {
  const supabase = createAdminClient()

  console.log("[getSettlementsByDistrictName] Fetching for district:", districtName)

  // First, find the district code by name
  const { data: districtData, error: districtError } = await supabase
    .from("kladr_places")
    .select("code")
    .or("socr.eq.—Ä-–Ω,socr.eq.–≥.–æ.,socr.eq.–≥–æ—Ä–æ–¥—Å–∫–æ–π –æ–∫—Ä—É–≥,socr.eq.—Ä–∞–π–æ–Ω")
    .ilike("name", `%${districtName.split(' ')[0]}%`)
    .limit(1)
    .single()

  if (districtError || !districtData) {
    console.error("[getSettlementsByDistrictName] District not found:", districtError)
    return []
  }

  const districtCode = districtData.code.substring(0, 5) // First 5 chars = district code
  console.log("[getSettlementsByDistrictName] District code:", districtCode)

  // Get settlements that belong to this district (code starts with district code)
  const { data, error } = await supabase
    .from("kladr_places")
    .select("code, name, socr")
    .or("socr.eq.–≥,socr.eq.–ø,socr.eq.–ø–æ—Å,socr.eq.—Å,socr.eq.–¥")
    .like("code", `${districtCode}%`)
    .order("name", { ascending: true })

  if (error) {
    console.error("[getSettlementsByDistrictName] Error:", error)
    return []
  }

  console.log("[getSettlementsByDistrictName] Fetched settlements:", data?.length)

  // Transform to match Settlement interface
  return (data || []).map(s => ({
    id: s.code,
    district_id: districtCode,
    name: `${s.socr ? s.socr + '. ' : ''}${s.name}`,
    settlement_type: s.socr,
    sort_order: 0,
    is_active: true,
    created_at: new Date().toISOString(),
    updated_at: new Date().toISOString()
  }))
}

export async function getStreets(settlementCode?: string) {
  const supabase = createAdminClient()

  console.log("[getStreets] Fetching streets from kladr_streets...")

  let query = supabase
    .from("kladr_streets")
    .select("code, name, socr, place_code")

  if (settlementCode) {
    query = query.eq("place_code", settlementCode)
  }

  const { data, error } = await query.order("name", { ascending: true })

  if (error) {
    console.error("[getStreets] Error fetching streets:", error)
    return []
  }

  console.log("[getStreets] Fetched streets:", data)

  // Transform to match Street interface
  return (data || []).map(s => ({
    id: s.code,
    settlement_id: s.place_code,
    name: `${s.socr ? s.socr + '. ' : ''}${s.name}`,
    street_type: s.socr,
    sort_order: 0,
    is_active: true,
    created_at: new Date().toISOString(),
    updated_at: new Date().toISOString()
  }))
}

export async function getSettlementDescriptions(districtName?: string) {
  const supabase = createAdminClient()

  let query = supabase
    .from("settlement_descriptions")
    .select("id, district_name, settlement_name, description, created_at, updated_at")
    .order("district_name", { ascending: true })
    .order("settlement_name", { ascending: true })

  if (districtName && districtName !== "all") {
    query = query.eq("district_name", districtName)
  }

  const { data, error } = await query
  if (error) {
    console.error("[getSettlementDescriptions] Error:", error)
    return []
  }

  return data || []
}

export async function getSettlementDescription(districtName: string, settlementName: string) {
  const supabase = createAdminClient()

  const { data, error } = await supabase
    .from("settlement_descriptions")
    .select("id, district_name, settlement_name, description, created_at, updated_at")
    .eq("district_name", districtName)
    .eq("settlement_name", settlementName)
    .maybeSingle()

  if (error) {
    console.error("[getSettlementDescription] Error:", error)
    return null
  }

  return data || null
}

export async function upsertSettlementDescription(districtName: string, settlementName: string, description: string) {
  const supabase = createAdminClient()

  const payload = {
    district_name: districtName,
    settlement_name: settlementName,
    description,
    updated_at: new Date().toISOString(),
  }

  const { data, error } = await supabase
    .from("settlement_descriptions")
    .upsert(payload, { onConflict: "district_name,settlement_name" })
    .select("id, district_name, settlement_name, description, created_at, updated_at")
    .single()

  if (error) {
    console.error("[upsertSettlementDescription] Error:", error)
    throw new Error(error.message)
  }

  return data
}

export async function deleteSettlementDescription(districtName: string, settlementName: string) {
  const supabase = createAdminClient()

  const { error } = await supabase
    .from("settlement_descriptions")
    .delete()
    .eq("district_name", districtName)
    .eq("settlement_name", settlementName)

  if (error) {
    console.error("[deleteSettlementDescription] Error:", error)
    throw new Error(error.message)
  }

  return { success: true }
}

export async function applySettlementDescriptionToPlots(
  settlementName: string,
  description: string
): Promise<{ success: boolean; updatedCount: number; error?: string }> {
  const supabase = createAdminClient()

  try {
    // Update all land plots where location matches the settlement name
    const { data, error } = await supabase
      .from("land_plots")
      .update({
        description: description,
        updated_at: new Date().toISOString(),
      })
      .eq("location", settlementName)
      .select("id")

    if (error) {
      console.error("[applySettlementDescriptionToPlots] Error:", error)
      return { success: false, updatedCount: 0, error: error.message }
    }

    const updatedCount = data?.length || 0

    revalidatePath("/")
    revalidatePath("/admin")

    return { success: true, updatedCount }
  } catch (error) {
    console.error("[applySettlementDescriptionToPlots] Error:", error)
    return { success: false, updatedCount: 0, error: String(error) }
  }
}

export async function renameSettlement(
  kladrCode: string,
  newName: string
): Promise<{ success: boolean; updatedPlots: number; error?: string }> {
  const supabase = createAdminClient()

  try {
    // Get the current settlement info
    const { data: settlement, error: fetchError } = await supabase
      .from("kladr_places")
      .select("code, name, socr")
      .eq("code", kladrCode)
      .single()

    if (fetchError || !settlement) {
      return { success: false, updatedPlots: 0, error: "–ü–æ—Å–µ–ª–æ–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω" }
    }

    // Build the old full name (with prefix like "–ø. ")
    const oldFullName = (settlement.socr ? settlement.socr + ". " : "") + settlement.name

    // Update the settlement name in kladr_places
    const { error: updateKladrError } = await supabase
      .from("kladr_places")
      .update({ name: newName.replace(/^(–ø\.|–≥\.|—Å\.|–¥\.|–ø–æ—Å\.)\s*/i, "").trim() })
      .eq("code", kladrCode)

    if (updateKladrError) {
      return { success: false, updatedPlots: 0, error: updateKladrError.message }
    }

    // Build the new full name
    const newFullName = (settlement.socr ? settlement.socr + ". " : "") + newName.replace(/^(–ø\.|–≥\.|—Å\.|–¥\.|–ø–æ—Å\.)\s*/i, "").trim()

    // Update all land plots with this location
    const { data: updatedPlots, error: updatePlotsError } = await supabase
      .from("land_plots")
      .update({
        location: newFullName,
        updated_at: new Date().toISOString()
      })
      .eq("location", oldFullName)
      .select("id")

    if (updatePlotsError) {
      console.error("[renameSettlement] Error updating plots:", updatePlotsError)
      // Settlement was renamed but plots failed - still partial success
      return { success: true, updatedPlots: 0, error: "–ü–æ—Å–µ–ª–æ–∫ –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω, –Ω–æ —É—á–∞—Å—Ç–∫–∏ –Ω–µ –æ–±–Ω–æ–≤–ª–µ–Ω—ã: " + updatePlotsError.message }
    }

    // Also update settlement_descriptions if exists
    await supabase
      .from("settlement_descriptions")
      .update({ settlement_name: newFullName })
      .eq("settlement_name", oldFullName)

    revalidatePath("/")
    revalidatePath("/admin")

    return { success: true, updatedPlots: updatedPlots?.length || 0 }
  } catch (error) {
    console.error("[renameSettlement] Error:", error)
    return { success: false, updatedPlots: 0, error: String(error) }
  }
}

export async function getDuplicateSettlements(): Promise<{
  inDistrict: Array<{
    name: string
    district: string
    count: number
    codes: string[]
  }>
  acrossDistricts: Array<{
    name: string
    districts: string[]
    count: number
  }>
}> {
  const supabase = createAdminClient()

  // Get all settlements
  const { data: settlements } = await supabase
    .from("kladr_places")
    .select("code, name, socr")
    .or("socr.eq.–≥,socr.eq.–ø,socr.eq.–ø–æ—Å,socr.eq.—Å,socr.eq.–¥")

  // Get districts
  const { data: districts } = await supabase
    .from("kladr_places")
    .select("code, name, socr")
    .or("socr.eq.—Ä-–Ω,socr.eq.–≥.–æ.,socr.eq.–≥–æ—Ä–æ–¥—Å–∫–æ–π –æ–∫—Ä—É–≥,socr.eq.—Ä–∞–π–æ–Ω")

  const districtMap: Record<string, string> = {}
  for (const d of districts || []) {
    districtMap[d.code.substring(0, 5)] = d.name + " " + d.socr
  }

  // Group by full name
  const byName: Record<string, Array<{ code: string; district: string }>> = {}
  for (const s of settlements || []) {
    const fullName = (s.socr ? s.socr + ". " : "") + s.name
    if (!byName[fullName]) byName[fullName] = []
    byName[fullName].push({
      code: s.code,
      district: districtMap[s.code.substring(0, 5)] || "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ä–∞–π–æ–Ω"
    })
  }

  const inDistrict: Array<{ name: string; district: string; count: number; codes: string[] }> = []
  const acrossDistricts: Array<{ name: string; districts: string[]; count: number }> = []

  for (const [name, items] of Object.entries(byName)) {
    // Group by district
    const byDistrict: Record<string, string[]> = {}
    for (const item of items) {
      if (!byDistrict[item.district]) byDistrict[item.district] = []
      byDistrict[item.district].push(item.code)
    }

    // Check for duplicates within same district
    for (const [district, codes] of Object.entries(byDistrict)) {
      if (codes.length > 1) {
        inDistrict.push({ name, district, count: codes.length, codes })
      }
    }

    // Check for same name across different districts
    const uniqueDistricts = Object.keys(byDistrict)
    if (uniqueDistricts.length > 1) {
      acrossDistricts.push({ name, districts: uniqueDistricts, count: items.length })
    }
  }

  return { inDistrict, acrossDistricts }
}

// ============ AI SETTINGS ============

const DEFAULT_SETTLEMENT_PROMPT = `–¢—ã ‚Äî —ç–∫—Å–ø–µ—Ä—Ç –ø–æ –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏ –≤ –ö–∞–ª–∏–Ω–∏–Ω–≥—Ä–∞–¥—Å–∫–æ–π –æ–±–ª–∞—Å—Ç–∏. 
–ù–∞–ø–∏—à–∏ –ø—Ä–∏–≤–ª–µ–∫–∞—Ç–µ–ª—å–Ω–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –∑–µ–º–µ–ª—å–Ω–æ–≥–æ —É—á–∞—Å—Ç–∫–∞ –≤ —É–∫–∞–∑–∞–Ω–Ω–æ–º –ø–æ—Å—ë–ª–∫–µ.
–û–ø–∏—Å–∞–Ω–∏–µ –¥–æ–ª–∂–Ω–æ –≤–∫–ª—é—á–∞—Ç—å:
- –≠–º–æ–¥–∑–∏ –¥–ª—è –≤–∏–∑—É–∞–ª—å–Ω–æ–≥–æ –æ—Ñ–æ—Ä–º–ª–µ–Ω–∏—è (üè°üìçüöå‚ö°üå≤‚úÖ)
- –†–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏–µ –∏ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –¥–æ –ö–∞–ª–∏–Ω–∏–Ω–≥—Ä–∞–¥–∞
- –¢—Ä–∞–Ω—Å–ø–æ—Ä—Ç–Ω—É—é –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å
- –ö–æ–º–º—É–Ω–∏–∫–∞—Ü–∏–∏ (—ç–ª–µ–∫—Ç—Ä–∏—á–µ—Å—Ç–≤–æ, –≥–∞–∑, –≤–æ–¥–∞)
- –ü—Ä–∏—Ä–æ–¥—É –∏ —ç–∫–æ–ª–æ–≥–∏—é
- –ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞ –ø–æ–∫—É–ø–∫–∏

–§–æ—Ä–º–∞—Ç –æ—Ç–≤–µ—Ç–∞ ‚Äî —Ç–æ–ª—å–∫–æ —Ç–µ–∫—Å—Ç –æ–ø–∏—Å–∞–Ω–∏—è, –±–µ–∑ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã—Ö –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤.
–ü–∏—à–∏ –Ω–∞ —Ä—É—Å—Å–∫–æ–º —è–∑—ã–∫–µ. –ò—Å–ø–æ–ª—å–∑—É–π —Ä–µ–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –æ –ø–æ—Å—ë–ª–∫–µ –µ—Å–ª–∏ –∑–Ω–∞–µ—à—å –∏—Ö.`

export async function getAiSettings(): Promise<{
  settlementPrompt: string
  apiProvider: string
}> {
  const supabase = createAdminClient()

  const { data, error } = await supabase
    .from("organization_settings")
    .select("ai_settlement_prompt, ai_provider")
    .single()

  if (error || !data) {
    return {
      settlementPrompt: DEFAULT_SETTLEMENT_PROMPT,
      apiProvider: "perplexity",
    }
  }

  return {
    settlementPrompt: data.ai_settlement_prompt || DEFAULT_SETTLEMENT_PROMPT,
    apiProvider: data.ai_provider || "perplexity",
  }
}

export async function updateAiSettings(settings: {
  settlementPrompt?: string
  apiProvider?: string
}): Promise<{ success: boolean; error?: string }> {
  const supabase = createAdminClient()

  const updateData: Record<string, unknown> = {
    updated_at: new Date().toISOString(),
  }

  if (settings.settlementPrompt !== undefined) {
    updateData.ai_settlement_prompt = settings.settlementPrompt
  }
  if (settings.apiProvider !== undefined) {
    updateData.ai_provider = settings.apiProvider
  }

  const { error } = await supabase
    .from("organization_settings")
    .update(updateData)
    .eq("id", "00000000-0000-0000-0000-000000000001")

  if (error) {
    console.error("[updateAiSettings] Error:", error)
    return { success: false, error: error.message }
  }

  revalidatePath("/admin")
  return { success: true }
}

export async function generateSettlementDescription(
  districtName: string,
  settlementName: string
): Promise<{ success: boolean; description?: string; error?: string }> {
  try {
    const settings = await getAiSettings()

    const apiUrl = process.env.PERPLEXITY_API_URL || "https://api.perplexity.ai/chat/completions"
    const apiKey = process.env.PERPLEXITY_API_KEY

    if (!apiKey) {
      return { success: false, error: "API –∫–ª—é—á Perplexity –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω" }
    }

    const userMessage = `–ù–∞–ø–∏—à–∏ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –ø–æ—Å—ë–ª–∫–∞ "${settlementName}" –≤ ${districtName}, –ö–∞–ª–∏–Ω–∏–Ω–≥—Ä–∞–¥—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å.`

    const response = await fetch(apiUrl, {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${apiKey}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        model: "sonar",
        messages: [
          { role: "system", content: settings.settlementPrompt },
          { role: "user", content: userMessage },
        ],
        temperature: 0.7,
        max_tokens: 1500,
      }),
    })

    if (!response.ok) {
      const errorText = await response.text()
      console.error("[generateSettlementDescription] API Error:", errorText)
      return { success: false, error: `–û—à–∏–±–∫–∞ API: ${response.status}` }
    }

    const data = await response.json()
    const generatedText = data.choices?.[0]?.message?.content || ""

    return { success: true, description: generatedText }
  } catch (error) {
    console.error("[generateSettlementDescription] Error:", error)
    return { success: false, error: String(error) }
  }
}

export async function getPlotGeometry(cadastralNumber: string): Promise<{
  type: string
  coordinates: any
  properties: any
  crs?: string
} | null> {
  const client = new NspdClient();
  const { data: info } = await client.getObjectInfo(cadastralNumber);

  if (!info) return null;

  return {
    type: info.geometry.type,
    coordinates: info.geometry.coordinates,
    properties: { address: info.address }, // Simplified properties for compatibility
    crs: info.geometry.crs?.properties?.name || "EPSG:3857"
  };
}

export async function syncPlotCoordinates(plotId: string, cadastralNumber: string): Promise<boolean> {
  const supabase = createAdminClient()
  const client = new NspdClient();

  try {
    const { data: info, error: nspdError } = await client.getObjectInfo(cadastralNumber);

    if (!info || !info.centroid_wgs84) {
      await supabase
        .from("land_plots")
        .update({
          has_coordinates: false,
          sync_error: nspdError || "–ì–µ–æ–º–µ—Ç—Ä–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞",
          updated_at: new Date().toISOString()
        })
        .eq("id", plotId)
      return false
    }

    const detectedStatus = client.detectLandStatus(info);

    const { error } = await supabase
      .from("land_plots")
      .update({
        coordinates_json: info.geometry,
        has_coordinates: true,
        center_lat: info.centroid_wgs84[0],
        center_lon: info.centroid_wgs84[1],
        land_status: detectedStatus || undefined, // Only update if detected
        sync_error: null,
        updated_at: new Date().toISOString()
      })
      .eq("id", plotId)

    if (error) throw error
    return true
  } catch (error) {
    console.error(`[syncPlotCoordinates] Error for ${plotId}:`, error)
    return false
  }
}

/**
 * Manually sync coordinates and (optionally) address for a single plot.
 */
export async function syncSinglePlot(id: string): Promise<{ success: boolean; error?: string }> {
  try {
    const supabase = createAdminClient()
    const { data: plot, error: fetchError } = await supabase
      .from("land_plots")
      .select("id, cadastral_number")
      .eq("id", id)
      .single()

    if (fetchError || !plot || !plot.cadastral_number) {
      return { success: false, error: "–£—á–∞—Å—Ç–æ–∫ —Å –∫–∞–¥–∞—Å—Ç—Ä–æ–≤—ã–º –Ω–æ–º–µ—Ä–æ–º –Ω–µ –Ω–∞–π–¥–µ–Ω" }
    }

    const ok = await syncPlotCoordinates(plot.id, plot.cadastral_number)

    if (ok) {
      revalidatePath("/admin")
      return { success: true }
    } else {
      return { success: false, error: "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –∏–∑ –ù–°–ü–î" }
    }
  } catch (err) {
    console.error("[syncSinglePlot] Error:", err)
    return { success: false, error: String(err) }
  }
}

export async function batchSyncCoordinates(limit = 20): Promise<{ success: boolean; processed: number; found: number }> {
  const supabase = createAdminClient()

  try {
    // Find plots without coordinates that have a cadastral number
    const { data: plots, error } = await supabase
      .from("land_plots")
      .select("id, cadastral_number")
      .eq("has_coordinates", false)
      .not("cadastral_number", "is", null)
      .limit(limit)

    if (error) throw error
    if (!plots || plots.length === 0) return { success: true, processed: 0, found: 0 }

    let found = 0
    for (const plot of plots) {
      const ok = await syncPlotCoordinates(plot.id, plot.cadastral_number)
      if (ok) found++
      // Throttle to respect NSPD API
      await new Promise(resolve => setTimeout(resolve, 500))
    }

    revalidatePath("/admin")
    return { success: true, processed: plots.length, found }
  } catch (error) {
    console.error("[batchSyncCoordinates] Error:", error)
    return { success: false, processed: 0, found: 0 }
  }
}

/**
 * Automatically resolve location (district and settlement) from cadastral number using NSPD and KLADR.
 */
export async function resolveLocationByCadastral(cadastralNumber: string): Promise<{
  district?: string;
  location?: string;
  land_status?: string;
  error?: string;
  debug?: any;
}> {
  const client = new NspdClient();
  const supabase = createAdminClient();

  try {
    const { data: info, error: nspdError } = await client.getObjectInfo(cadastralNumber);

    if (nspdError || !info || !info.address) {
      return { error: nspdError || "–ê–¥—Ä–µ—Å –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –ù–°–ü–î" };
    }

    const nspdAddress = info.address;
    const landStatus = client.detectLandStatus(info);

    // Parse NSPD address to find district and settlement hints
    const parts = nspdAddress.split(',').map(p => p.trim());

    let detectedDistrictName = "";
    let detectedSettlementName = ""; // Can be settlement or city

    // 1. Detect District Hint from string
    const districtPart = parts.find(p =>
      p.includes("—Ä-–Ω") || p.includes("–≥.–æ.") || p.includes("–≥–æ—Ä–æ–¥—Å–∫–æ–π –æ–∫—Ä—É–≥") || p.includes("—Ä–∞–π–æ–Ω")
    );

    if (districtPart) {
      detectedDistrictName = districtPart
        .replace(/—Ä-–Ω|–≥\.–æ\.|–≥–æ—Ä–æ–¥—Å–∫–æ–π –æ–∫—Ä—É–≥|—Ä–∞–π–æ–Ω/g, "")
        .trim();
    }

    // 2. Detect Settlement Hint from string
    const settlementMarkers = ["–≥ ", "–ø ", "–ø–æ—Å ", "—Å ", "–¥ ", "—Å—Ç-—Ü–∞ ", "—Ö "];
    const settlementPart = parts.find(p =>
      settlementMarkers.some(marker => p.startsWith(marker)) ||
      p.includes(" –≥") || p.includes(" –ø ") || p.includes(" –ø–æ—Å")
    );

    if (settlementPart) {
      detectedSettlementName = settlementPart
        .replace(/–≥\.|–ø\.|–ø–æ—Å\.|—Å\.|–¥\.|—Å—Ç-—Ü–∞|—Ö\.|–≥ |–ø |–ø–æ—Å |—Å |–¥ /g, "")
        .trim();
    } else if (!districtPart && parts.length > 2) {
      // Fallback usually for city districts if no explicit district part
      // e.g. "–ö–∞–ª–∏–Ω–∏–Ω–≥—Ä–∞–¥—Å–∫–∞—è –æ–±–ª, –≥ –ö–∞–ª–∏–Ω–∏–Ω–≥—Ä–∞–¥, ..."
      const potentialCity = parts[1];
      if (potentialCity.includes("–≥ ") || potentialCity.includes("–≥.")) {
        detectedSettlementName = potentialCity.replace(/–≥\.|–≥ /g, "").trim();
      }
    }


    // 3. STRICT MATCHING AGAINST DATABASE
    // We want to return ONLY values that exist in our DB to maintain integrity.

    let dbDistrictId: string | null = null;
    let finalDistrictName = "";
    let finalSettlementName = "";

    // 3a. Find District in DB
    if (detectedDistrictName) {
      // Search by name (ilike)
      const { data: districts } = await supabase
        .from("districts")
        .select("id, name")
        .ilike("name", `%${detectedDistrictName}%`)
        .limit(1);

      if (districts && districts.length > 0) {
        dbDistrictId = districts[0].id;
        finalDistrictName = districts[0].name;
      }
    } else if (detectedSettlementName === "–ö–∞–ª–∏–Ω–∏–Ω–≥—Ä–∞–¥") {
      // Special case for Kaliningrad city which often acts as its own district in address structures
      const { data: districts } = await supabase
        .from("districts")
        .select("id, name")
        .ilike("name", `%–ö–∞–ª–∏–Ω–∏–Ω–≥—Ä–∞–¥%`)
        .limit(1);

      if (districts && districts.length > 0) {
        dbDistrictId = districts[0].id;
        // Usually "–≥. –ö–∞–ª–∏–Ω–∏–Ω–≥—Ä–∞–¥" is the district name in DB too, or similar
        finalDistrictName = districts[0].name;
      }
    }

    // 3b. Find Settlement in DB
    if (detectedSettlementName && dbDistrictId) {
      // If we have a district, search settlement strictly within it
      const { data: mills } = await supabase
        .from("settlements")
        .select("name")
        .eq("district_id", dbDistrictId)
        .ilike("name", `%${detectedSettlementName}%`)
        .limit(1);

      if (mills && mills.length > 0) {
        finalSettlementName = mills[0].name;
      }
    } else if (detectedSettlementName && !dbDistrictId) {
      // If we failed to find a district, try global settlement search (less accurate but helpful)
      const { data: mills } = await supabase
        .from("settlements")
        .select("name, districts(name)")
        .ilike("name", `%${detectedSettlementName}%`)
        .limit(1);

      if (mills && mills.length > 0) {
        finalSettlementName = mills[0].name;
        // Also backfill district if we found a unique settlement match
        if (mills[0].districts) {
          // @ts-ignore
          finalDistrictName = mills[0].districts.name;
        }
      }
    }

    // Fallback: If strict DB match failed, we might chose to return nothing for location
    // to force manual entry, OR return the raw detected name marked as 'unknown'.
    // The requirement says: "–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –¥–ª—è —É—á–∞—Å—Ç–∫–∞ —Ä–∞–π–æ–Ω –∏ –ø–æ—Å–µ–ª–æ–∫ ( –ê–¥—Ä–µ—Å–∞ –∑–∞–≥—Ä—É–∂–µ–Ω—ã –≤ –ë–î –±—Ä—è—Ç—å –∏–∑ –±–¥ –∞–¥—Ä–µ—Å–∞ )"
    // So we prefer DB matches.

    return {
      district: finalDistrictName || undefined, // undefined if no DB match
      location: finalSettlementName || undefined, // undefined if no DB match
      land_status: landStatus || undefined,
      debug: { nspdAddress, detectedDistrictName, detectedSettlementName, finalDistrictName, finalSettlementName }
    };

  } catch (error) {
    console.error("[resolveLocationByCadastral] Error:", error);
    return { error: String(error) };
  }
}

// ============ FAQ ============

export async function getFaqItems(activeOnly = false): Promise<FaqItem[]> {
  const supabase = createAdminClient()

  let query = supabase.from("faq_items").select("*").order("sort_order", { ascending: true })

  if (activeOnly) {
    query = query.eq("is_active", true)
  }

  const { data, error } = await query

  if (error) {
    console.error("Error fetching faq items:", error)
    return []
  }

  return data as FaqItem[]
}

export async function createFaqItem(data: Partial<FaqItem>): Promise<FaqItem | null> {
  const supabase = createAdminClient()

  const { data: item, error } = await supabase
    .from("faq_items")
    .insert({
      question: data.question,
      answer: data.answer,
      category: data.category || "general",
      icon: data.icon,
      is_active: data.is_active ?? true,
      sort_order: data.sort_order ?? 0,
    })
    .select()
    .single()

  if (error) {
    console.error("Error creating faq item:", error)
    throw new Error(error.message)
  }

  revalidatePath("/admin")
  revalidatePath("/faq")
  revalidatePath("/")

  return item as FaqItem
}

export async function updateFaqItem(id: string, data: Partial<FaqItem>): Promise<FaqItem | null> {
  const supabase = createAdminClient()

  const { data: item, error } = await supabase
    .from("faq_items")
    .update({
      ...data,
      updated_at: new Date().toISOString(),
    })
    .eq("id", id)
    .select()
    .single()

  if (error) {
    console.error("Error updating faq item:", error)
    throw new Error(error.message)
  }

  revalidatePath("/admin")
  revalidatePath("/faq")
  revalidatePath("/")

  return item as FaqItem
}

export async function deleteFaqItem(id: string): Promise<void> {
  const supabase = createAdminClient()

  const { error } = await supabase.from("faq_items").delete().eq("id", id)

  if (error) {
    console.error("Error deleting faq item:", error)
    throw new Error(error.message)
  }

  revalidatePath("/admin")
  revalidatePath("/faq")
}

// LEGAL CONTENT ACTIONS
export async function getLegalContent(onlyActive = false) {
  const supabase = createAdminClient()
  let query = supabase.from("legal_content").select("*").order("sort_order", { ascending: true })

  if (onlyActive) {
    query = query.eq("is_active", true)
  }

  const { data, error } = await query
  if (error) {
    console.error("Error fetching legal content:", error)
    return []
  }
  return data as LegalContent[]
}

export async function createLegalContent(data: Partial<LegalContent>) {
  const supabase = createAdminClient()
  const { data: inserted, error } = await supabase
    .from("legal_content")
    .insert(data)
    .select("*")
    .single()

  if (error) {
    console.error("Error creating legal content:", error)
    return null
  }
  revalidatePath("/admin")
  revalidatePath("/legal")
  return inserted as LegalContent
}

export async function updateLegalContent(id: string, data: Partial<LegalContent>) {
  const supabase = createAdminClient()
  const { data: updated, error } = await supabase
    .from("legal_content")
    .update({ ...data, updated_at: new Date().toISOString() })
    .eq("id", id)
    .select("*")
    .single()

  if (error) {
    console.error("Error updating legal content:", error)
    return null
  }
  revalidatePath("/admin")
  revalidatePath("/legal")
  return updated as LegalContent
}

export async function deleteLegalContent(id: string) {
  const supabase = createAdminClient()
  const { error } = await supabase.from("legal_content").delete().eq("id", id)
  if (error) {
    console.error("Error deleting legal content:", error)
    return false
  }
  revalidatePath("/admin")
  revalidatePath("/legal")
  return true
}

export async function reorderLegalContent(updates: { id: string; sort_order: number }[]) {
  const supabase = createAdminClient()
  // Manual reorder since RPC might not be available
  for (const update of updates) {
    await supabase.from("legal_content").update({ sort_order: update.sort_order }).eq("id", update.id)
  }

  revalidatePath("/admin")
  revalidatePath("/legal")
  return true
}


export async function reorderFaqItems(items: { id: string; sort_order: number }[]): Promise<{ success: boolean }> {
  const supabase = createAdminClient()

  // Use a transaction-like approach with multiple updates if supabase allows, 
  // or just run them in parallel for a small number of items.
  const updates = items.map((item) =>
    supabase.from("faq_items").update({ sort_order: item.sort_order }).eq("id", item.id)
  )

  await Promise.all(updates)

  revalidatePath("/admin")
  revalidatePath("/faq")
  return { success: true }
}

// ============ CHAT WIDGET ACTIONS ============

export async function getChatMessages(sessionId: string) {
  const supabase = createAdminClient()
  const { data, error } = await supabase
    .from("chat_messages")
    .select("*")
    .eq("session_id", sessionId)
    .order("created_at", { ascending: true })

  if (error) {
    console.error("[getChatMessages] Error:", error)
    return []
  }
  return data
}

export async function sendChatMessage(sessionId: string, text: string) {
  const supabase = createAdminClient()

  // 1. Ensure session exists or update last_message_at
  const { data: session, error: sessionError } = await supabase
    .from("chat_sessions")
    .upsert({ id: sessionId, last_message_at: new Date().toISOString() }, { onConflict: "id" })
    .select()
    .single()

  if (sessionError) {
    console.error("[sendChatMessage] Session error:", sessionError)
    return { success: false, error: sessionError.message }
  }

  // 2. Save message locally
  const { data: message, error: messageError } = await supabase
    .from("chat_messages")
    .insert({
      session_id: sessionId,
      text,
      sender: "user",
    })
    .select()
    .single()

  if (messageError) {
    console.error("[sendChatMessage] Message error:", messageError)
    return { success: false, error: messageError.message }
  }

  // 3. Send to Telegram
  const botToken = process.env.TELEGRAM_BOT_TOKEN
  const adminChatId = process.env.ADMIN_CHAT_ID

  if (botToken && adminChatId) {
    try {
      const tgMsg = `üí¨ <b>–ù–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏–∑ —á–∞—Ç–∞</b>\n\nID —Å–µ—Å—Å–∏–∏: <code>${sessionId.slice(0, 8)}</code>\n\n${text}\n\n<i>–û—Ç–≤–µ—Ç—å—Ç–µ –Ω–∞ —ç—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ Telegram, —á—Ç–æ–±—ã –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –æ—Ç–≤–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é.</i>`

      const response = await fetch(`https://api.telegram.org/bot${botToken}/sendMessage`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          chat_id: adminChatId,
          text: tgMsg,
          parse_mode: "HTML",
        }),
      })

      const tgData = await response.json()
      if (tgData.ok) {
        // Store telegram_message_id to map replies later
        await supabase
          .from("chat_messages")
          .update({ telegram_message_id: tgData.result.message_id })
          .eq("id", message.id)
      }
    } catch (e) {
      console.error("[sendChatMessage] TG error:", e)
    }
  }

  return { success: true, message }
}
